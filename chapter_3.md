# 문자 집합으로 찾기

## 여러 문자 중 하나와 일치하기

다음과 같은 파일 목록이 있습니다.

```txt
sales.xls
sales1.xls
orders3.xls
sales2.xls
sales3.xls
apac1.xls
europe2.xls
na1.xls
na2.xls
sa1.xls
```

이 목록은 `ex/3_1.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_1.txt
```

여기서 `na`, `sa`를 찾고자 할 때, `.a`을 사용할 수 있습니다. 그러나 이 패턴에는 `ca`도 걸립니다. `a`의 앞 글자가 `n`, `s`인 경우만 찾고 싶은 경우, 이 두 문자를 `[]`으로 묶어서, `[ns]`이라고 지정합니다. 이것은 문자 집합이기 때문에 각 문자를 원소로 집합을 만든 것입니다. 당연히 `[`와 `]`은 메타 문자입니다.

- 정규 표현식: `[ns]a.\.xls`

**참고로** 정규 표현식에 `[, ]`가 들어가면 터미널에서는 문제가 발생할 수 있으니 `'`을 이용해서 정규 표현식 패턴을 감싸야 `grep`나 `rg`를 사용할 때 문제가 발생하지 않습니다.

```bash
rg '[ns]a.\.xls' ex/3_1.txt
```

만약 대소문자 구별하지 않고 찾고 싶은 경우에도 위의 방법을 사용할 수 있습니다.

```txt
The phrase "regular expression" in often
abbreviated as RegEx or regex.
```

이 내용은 `ex/3_2.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_2.txt
```

위와 같은 문서에서 `RegEx`과 `regex`을 동시에 일치하는 것을 찾는다고 합시다. 이때도 앞에서 사용한 방법을 사용해서 찾으시면 됩니다.

정규 표현식: `[Rr]eg[Ee]x`

```bash
rg '[Rr]eg[Ee]x' ex/3_2.txt
```

물론 이 방식은 `REGEX`과 같은 것을 찾을 수 었습니다.
```txt
RegEx
regex
REGEX
```

이 내용은 `ex/3_3.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_3.txt
```

다음 파일에서 같은 위의 패턴을 이용하면`REGEX`을 찾지 못하는 것을 확인할 수 있습니다.

```bash
rg '[Rr]eg[Ee]x' ex/3_3.txt
```

## 문자 집합 범위 사용하기

앞에서 사용한 `[ns]a.\.xls`은 또다른 문제가 있습니다. 다음과 같은 문자열이 있습니다.

```text
sales1.xls
orders3.xls
sales2.xls
sales3.xls
apac1.xls
europe2.xls
sam.xls
na1.xls
na2.xls
sa1.xls
```

이것은 `ex/3_3.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_3.txt
```

앞에서와 같은 패턴을 가지고 일치라는 것을 것을 찾아봅시다.

```bash
rg '[ns]a.\.xls' ex/3_4.txt
```

결과는 다음과 같습니다.

```bash
rg '[ns]a.\.xls' ex/3_4.txt

7:sam.xls
8:na1.xls
9:na2.xls
10:sa1.xls
```

`.`은 숫자만 일치한다고 하는 것이 아니라 모든 문자를 뜻하는 것이기 때문에 `sam.xls`도 일치한다고 알려주고 있습니다. 그러나 우리가 찾고자 하는 것은 `na1.xls`, `na2.xls`, `sa1.xls`과 같이 `a` 글자 뒤에 숫자만 들어가는 것입니다. 이걸 구현하는 가장 단순한 방법은 아래와 같이 모든 숫자를 넣어서 일치하는 것을 찾으면 됩니다.

정규 표현식: `[ns]a[0123456789]\.xls`

```bash
rg '[ns]a[0123456789]\.xls' ex/3_4.txt
```

이 패턴은 첫 번째 문자는 `n` 또는 `s`이고 두 번째 문자는 `a` 그리고 세 번째 문자는 숫자중 하나면 되고 나머지 문자는 `.xls`과 일치하는 것을 찾으라는 것입니다. 결과는 다음과 같습니다.

```bash
rg '[ns]a[0123456789]\.xls' ex/3_4.txt

8:na1.xls
9:na2.xls
10:sa1.xls
```

문제가 없는 결과가 나왔습니다. 이렇게 문자 범위를 이용하고자 할 때에는 `[0-9]`과 같이 메타 문자인 `-`을 이용하면 됩니다. 참고로 `-`은 `[]`안에서만 메타 문자로 작동합니다. 그래서 만약 `-`을 찾고자 하는 경우에 `\.`처럼 `\`을 사용할 필요가 없습니다.

```bash
rg '[ns]a[0-9]\.xls' ex/3_4.txt
```

이것을 응용하면 다음과 같습니다. 주의할 점은 `[A-F]`처럼 특정 영역을 지정하는 경우에는 `[F-A]`과 같이 의미상 큰 값이 앞에 오는 경우에는 작동하지 않는 경우도 있습니다.

- `[A-Z]`: A부터 Z까지 모든 대문자.
- `[A-F]`: A부터 F까지 모든 대문자.
- `[a-z]`: a부터 z까지 모든 소문자.
- `[A-z]`: A부터 z까지 문자. 그러나 모든 아스키 문자가 들어가 갈 수도 있으니, 비추!

이런 집합을 여러개를 합쳐 사용할 수도 있습니다.

정규 표현식: `[A-Za-z0-9]`

이 패턴은 모든 대소문 영문자와 숫자가 일치하는지를 찾는 것입니다.

다음과 같은 `html`에서 RGB 값만 찾아 보겠습니다.

```html
<BODY BCOLOR="#336633" TEXT="#FFFFFF"
MARGINWIDTH="®" MARGINHEIGHT="®" TOPMARGIN="®"
LEFTMARGIN="®">
```

이것은 `ex/3_5.html`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_5.html
```

RGB 값은 `#336633`처럼 맨 처음 숫자는 `#`이고 나머지 6개 숫자는 16진수이기 때문에 숫자는 `0-9`, 문자는 `a-f`, 그런데 대문자도 있을 수 있으니 `A-F` 패턴을 합치면 됩니다. 그런데 숫자가 6개이기 때문에 6번을 반복해야 합니다. 그러면 다음과 같습니다.

- 정규 표현식: `#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]`

이 표현식을 이용하려면 다음과 같이 하면 됩니다.

```bash
rg '#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]' ex/3_5.html
```

## 제외하고 찾기

앞에서는 `ex/3_4.txt`에서 특정 문자 뒤에 숫자를 포함하는 것을 다음과 같이 찾았습니다.

```bash
rg '[ns]a[0123456789]\.xls' ex/3_4.txt
```

결과는 다음과 같았습니다.

```python
rg '[ns]a[0123456789]\.xls' ex/3_4.txt

8:na1.xls
9:na2.xls
10:sa1.xls
```

이번에는 여기서 반대로 제외하고 싶은 문자열을 제외해 보겠습니다. 메타 문자인 `^`(캐럿) 문자를 사용하면 됩니다. 이것을 사용하게 되면 이것 뒤에 오는 문자, 또는 문자 집합, 문자 범위 등을 모두 제외하게 됩니다.  

- 정규 표현식: `[ns]a[^0-9]\.`

```python
rg '[ns]a[^0-9]\.xls' ex/3_4.txt
```

결과는 다음과 같습니다. `a` 문자 다음에 `숫자 빼고 아무 문자`, 그리고 `.`가 들어가는 것츨 찾게 됩니다. 참고로 바로 뒤에 오는 것만 제외하는 것이 아니라 그 뒤에 있는 모든 문자도 적용하게 됩니다.

```bash
rg '[ns]a[^0-9]\.xls' ex/3_4.txt

7:sam.xls
```

## 정리

- `[]`: 메타 문자, 집합, 그 집합 원소 중 한 문자라도 일치, 즉 `또는(OR)`
- `-`: 메타 문자, 범위 설정 `[]`안에서만 메타 문자!
- `^`: 메타 문자, 뒤에 지정한 것만 제외하고 어느 문자라도 일치
