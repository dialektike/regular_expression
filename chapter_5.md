# 4장 반복 찾기

이번 장에서는 여러번 반복해 나타나는 문자나 문자 집합을 어떻게 찾는지 알아보겠습니다.

## 몇 번 일치하는가?

지금까지 공부한 것을 토대로 이메일 주소와 일치하는 패턴을 찾아봅시다. 이메일의 기본 형식은 다음과 같습니다.

```text
text@text.text
t@t.t
```

이것은 `ex/5_1.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_1.txt
```

앞에서 배운 것을 토대로 이메일을 주소를 찾기 위해서 다음과 같은 패턴을 만들 수 있습니다.

- 정규 표현식: `\w@\w\.\w`

이 정규 표현식을 사용해봅시다.

```bash
rg '\w@\w\.\w' ex/5_1.txt
```

```bash
grep '\w@\w\.\w' ex/5_1.txt
```

우리가 예상한 것은 이메일 전체 문장을 다 선택해 주기를 원했지만 위의 코드를 실행하면, 2번째 줄인 `t@t.t`을 찾은 것을 확인할 수 있습니다. 왜냐하면 위의 정규표현식은 단지 아래와 같이 1 글자씩만 있는 것에만 일치하고 있기 때문입니다. 다시 말해 `\w`은 문자 1개만 일치하는 패턴이기 때문입니다. 그렇기 때문에 1번째 줄을 이메일 주소 전체를 정확하게 선택하지 못하고 2번째 줄은 정확하게 선택하고 있습니다. 아래 코드를 실행하면 정확하게 이해할 수 있습니다.

```bash
echo "text@text.text" | rg '\w@\w\.\w'
```

윗 코드에서 앞의 문자열에서 아무 것도 찾지 못 하고 있는 것을 알 수 있습니다.

### 문자 하나 이상 찾기

그러면 앞에서 한 문자가 아니라 `@`앞에 있는 문자열, `@`과 `.` 사이에 있는 문자열, `.` 뒤에 있는 문자열, 즉 여러 개의 문자열을 찾으려면 어떻게 해야 할까요? 하나 이상의 문자열을 찾기 위해서는 문자 뒤에 `+`를 븉이면 됩니다. 예를 들어 `a`는 `a`라는 한 글자를 찾지만 `a+`는 하나 이상 `a`가 연속적으로 있는 것을 찾습니다. 그리고 `[0-9]`는 숫자 1개를 찾지만, `[0-9]+`은 하나 이상 숫자가 연속적으로 있는 것을 찾습니다. 참고로 `[0-9+]`과 같이 하면 다른 결과가 나오게 됩니다. 이 패턴을 단순히 이야기하면 `[0,1,2,3,4,5,6,7,8,9,+]`와 일치하는 것을 찾는 패턴입니다. 참고로 `+` 문자를 찾으려고 한다면, 이스케이프 문자를 포함한 `\+`을 이용하면 됩니다.

- 정규 표현식: `+`: 하나 이상을 찾는다, 보기: `[0-9]+`, `w+`

다음과 같이 이메일 주소가 들어 있는 문자열에서 이메일 주소를 찾아보겠습니다.

```text
Send personal email to ben@forta.com. For questions about a book use support@forta.com. Feel free to send unsolicited email to spam@forta.com(wouldn't it be nice if it were that simple, huh?).
```

이것은 `ex/5_2.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_2.txt
```

그러면 위에서 만든 패턴을 이용해 봅시다.

```bash
rg '\w+@\w+\.\w+' ex/5_2.txt
```

적정하게 찾는 것을 확인할 수 있습니다. 다음 예제에도 위의 패턴을 적용해 봅시다.

```txt
Send personal email to ben@forta.com or ben.forta@forta.com. For questions about a book use support@forta.com. If your message is urgent try ben@urgent.forta.com. Feel free to send unsolicited email to spam@forta.com (wouldn't it be nice if it were that simple, huh?).
```

이것은 `ex/5_3.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_3.txt
```

그러면 위에서 만든 패턴을 이용해 봅시다.

```bash
rg '\w+@\w+\.\w+' ex/5_3.txt
```

이 패턴은 `ex/5_3.txt`에 들어 있는 5개의 이메일 주소 중 3개는 정확하게 찾지만, 아래 나머지 2개는 정확하게 찾지 못하고 있습니다.

1. `ben.forta@forta.com`
2. `ben@urgent.forta.com`

이 두 이메일 주소는 `@` 앞 뒤 주소에 `.`이 들어 있는 경우입니다. 이를 위의 패턴은 정확하게 찾지 못 하고 있습니다. 이를 해결하려면 문자와 `.`을 동시에 찾아야 할 것 같습니다. 문자 집합, `\w`과 `.`을 합친 `[\w.]`을 사용해 봅시다.

```bash
rg '[\w.]+@[\w.]+\.\w+' ex/5_3.txt
```

여기서 조심해 부분이 있습니다. 마지막 부분의 `\w+`을 다음과 같이 굳이 `[\w.]+`으로 바꿀 필요는 없을 것 같습니다.

```bash
rg '[\w.]+@[\w.]+\.[\w.]+' ex/5_3.txt
```

이렇게 하면 마지막에 있는 마침표(`.`)같이 검색되는 경우가 있습니다.

### 문자가 없는 경우나 하나 이상 연속하는 문자 찾기

메타 문자, `+`는 하나 이상 연속된 문자를 찾습니다. 그러나 문자가 없는 경우에는 찾지 못 하고 최소한 하나는 일치해야 합니다. 그래서 있을 수도 없을 수도 있는 문자와 일치하는 것을 찾으려고 한다면 메타 문자 `*`을 사용해야 합니다. 만약 아래 코드처럼 메타 문자 `.`만 사용한다면 뒤에 'B. Forta', 'Ben Forta'은 찾을 수 없습니다.

```bash
echo "B Forta, B. Forta, Ben  Forta" | rg 'B.Forta'
```

그러나 아래와 같이 `*`을 사용한다면 모두 선택하게 됩니다.

```bash
echo "B Forta, B. Forta, Ben  Forta" | rg 'B.*Forta'
```

이제 앞에서 살펴 봤던 이메일 주소 관련 문제로 돌아와 봅시다. 다음 문자열을 봅시다.

```txt
Hello .ben@forta.com is my email address.
```

이것은 `ex/5_4.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_4.txt
```

그러면 위에서 만든 패턴을 이용해서 윗 문자열에서 이메일 주소를 찾아 봅시다.

```bash
rg '[\w.]+@[\w.]+\.\w+' ex/5_4.txt
```

앞에서도 말했지만 `[\w.]+`는 아무 문자(`\w`)나 `.`이 하나 이상 있는 것을 찾는 것입니다. 그러므로 이메일 주소 맨 앞에 있는 `.`도 함께 포함해서 일치한다고 검색하게 되는 것입니다. 정확하게 `.`을 제외할 수 있는 패턴이 필요합니다. 다시 말해서 따라서 맨 앞 글자는 순전히 문자만 찾는 패턴이 되어야 합니다. 첫 문자는 순전히 영문자나 숫자만 있는 문자열을 찾는 패턴은 `\w+`입니다. 그리고 두 번째 문자부터는 아무 문자나 와도 상관이 없습니다.

```bash
rg '\w+[\w.]+@[\w.]+\.\w+' ex/5_4.txt
```

아주 정확하게 이메일 주소를 찾고 있습니다. 그러나 아쉽게도 윗 패턴의 문제점은 다음과 같이 맨 앞이 한 글자로 되어 있는 것을 찾을 수 없다는 점입니다. 정확하게 말하자면 윗 패턴은 두 글자 이상 있는 것만 찾을 수 있는 패턴입니다. 다음 코드를 실행하면 정확하게 알 수 있습니다.

```bash
echo "a@forta.com" | rg '\w+[\w.]+@[\w.]+\.\w+'
```

위의 코드를 사용하면 `a@forta.com`을 찾지 못 합니다. 이를 해결하기 위해서는 두 번째 문자 이상을 찾는 `[\w.]+`에서 `+`을 `[\w.]*`과 같이 `*`으로 바꾸면 됩니다.

```bash
echo "a@forta.com" | rg '\w+[\w.]*@[\w.]+\.\w+'
```

위의 패턴은 정확하게 `a@forta.com`을 찾습니다. 왜냐하면 두 번째 문자 이상을 찾는 `[\w.]₩`에서 `*`은 해당 문자가 있어서도 되고 없어도 되기 때문에, 다시 말해 만드시 있을 필요가 없기 때문입니다.

### 문자가 없거나 하나인 문자 찾기

`?`은 `*` 처럼 특정 문자가 있거나 없어도 되는 패턴이지만, `*`과 달리 문자나 집합이 있거나 없어도 되지만, 하나만 있어야 있어야 합니다. 다음 문자열을 봅시다.

```txt
The URL is http://www.forta.com/, to connect securely use https://www.forta.com/ instead.
```

이것은 `ex/5_5.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_5.txt
```

여기서 `http://`으로 시작하는 것과 일치하는 패턴을 찾고자 합니다. 쉽게 생각해서 `http://`으로 시작해먼서 영문자와 숫자, 그리고 `.`으로 되어 있는 것과 일치하는 패턴인 `http://[\w./]+`을 사용해 봅시다.

```bash
rg 'http://[\w./]+' ex/5_5.txt
```

당연히 위 패턴은 `https://www.forta.com/`에는 일치하는 않는 패턴입니다. 왜냐하면 `https`이 아니기 때문입니다. 다시 말해 우리는 `http`과 `https`을 모두 찾는 패턴이 필요합니다. 이때 필요한 것이 `?`입니다. `https?`과 같이 한다면 `s`가 있어도 되지만 없어도 된다는 것입니다.

```bash
rg 'https?://[\w./]+' ex/5_5.txt
```

그러나 앞에서 말했지만 `httpss`과 같이 `s`가 두 개가 있는 것과는 일치하지 않는 패턴입니다. 다음 코드를 실행하면 알 수 있습니다.

```bash
echo "httpss://www.forta.com/" | rg 'https?://[\w./]+'
```

그러나 `s`가 하나 있는 것은 일치합니다.

```bash
echo "https://www.forta.com/" | rg 'https?://[\w./]+'
```

## 구간(interval) 지정하기

주의할 점

- `+`, `*`은 일치하는 문자 수에 제한이 없습니다. 최대 몇 개까지 일치하는지 정할 수 없습니다.
- `+`, `*`, `?`은 일치하는 문자의 최솟값이 0이나 1입니다. 일치하는 문자 숫자의 최솟값을 명시적으로 지정할 수 없습니다.

따라서 이들은 정확히 원하는 만큼만 일치하도록 문자 수를 정의할 수 없습니다. 이를 위해 `{,}`을 사용해야 합니다.

### 정확한 구간 찾기

문자가 몇 번 연속해서 반복되는지 정확하게 지정하려면, `{`과 `}` 사이에 숫자를 지정하면 됩니다. 즉 `{3}`이라고 한다면 바로 앞에 있는 문자나 문자 집합이 세 번 연속해서 일치하는지를 확인할 수 있습니다. 앞에 연습한 것을 다시 한 번 가져 오겠습니다.

```html
<body
  BCOLOR="#336633"
  text="#FFFFFF"
  MARGINWIDTH="®"
  MARGINHEIGHT="®"
  TOPMARGIN="®"
  LEFTMARGIN="®"
></body>
```

이것은 `ex/3_5.html`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/3_5.html
```

3장에서는 이것 `#336633`과 `#FFFFFF`에 일치하는 패턴을 다음과 같이 `[0-9A-Fa-f]`을 6번 반복해서 만들었습니다.

- 정규 표현식: `#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]`

그러나 다음과 같이 `{6}`을 사용하여 6번 반복하는 것을 찾는 패턴을 만들 수 있습니다.

```bash
rg '#[0-9A-Fa-f]{6}' ex/3_5.html
```

### 범위 구간 찾기

앞에서는 정확하게 반복되는 횟수를 지정했지만, 이번에는 최소값과 최대값을 이용해서 반복되는 횟수를 지정해 보겠습니다. 아래와 같은 자료를 살펴봅시다.

```txt
4/8/03
10-6-2004
2/2/2
01-01-01
```

참고로 이것은 `ex/5_6.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_6.txt
```

위의 자료에서 날짜 자료가 들어 있는 줄을 찾고자 합니다. 만약 각 줄의 첫 번째 숫자와 두 번째 숫자는 최소 1 자리, 최대 2 자리 숫자이고 즉 `{1, 2}`, 3번째 숫자는 최소 2 자리, 최대 4 자리 숫자, 즉 `{2, 4}`인 것을 찾으면 될 것 같습니다. 그리고 각 숫자는 `-` 또는 `/` 으로, 즉 `[-\/]`으로 분리되어 있으면 될 것 같습니다.

```bash
rg '\d{1, 2}[-\/]\d{1, 2}[-\/]\d{2, 4}' ex/5_6.txt
```

그러나 이 패턴은 다음과 같이 숫자가 날짜 숫자가 아닌 것도 일치한다고 판정하고 있습니다.

```bash
echo "99-99-9999" | rg '\d{1, 2}[-\/]\d{1, 2}[-\/]\d{2, 4}'
```

따라서 정확한 검사를 하기 위해서는 부가적으로 각 숫자가 검사할 필요가 있습니다.

### 최소 구간 찾기

앞에서 처럼 최대값, 최소값, 두 개가 필요하지 않는 경우, 예를 들어 숫자가 최소 2자리 이상이라는 최소값만 검색하는 패턴을 사용하려면 `{3,}`이라고 하면 됩니다. 이는 곧 최소한 3 자리 이상은 일치하는 것을 찾으라는 것입니다.

- 정규 표현식: `{3,}` = 3자리 이상 찾아라!

이제 이를 이용해서 아래 자료에서 최소 100 달러 이상의 값만 찾아봅시다.

```txt
1001: $496.80
1002: $1290.69
1003: $26.43
1004: $613.42
1005: $7.61
1006: $414.90
1007: $25.00
```

참고로 이것은 `ex/5_7.txt`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_7.txt
```

```bash
rg '\d{1,}:\s\$\d{3,}\.\d{2}' ex/5_7.txt
```

윗 패턴을 자세히 살펴봅시다.

- `\d{1,}:`: 이것은 맨처음에 하나 이상의 숫자로 시작하고, 다음에 `:`이 들어갑니다.
- `\s\$`: 공백문자, 즉 스패이스가 하나 들어가고 `$`가 들어갑니다.
- `\d{3,}`: 숫자가 3자리 이상 들어갑니다.
- `\.\d{2}`: `.`이 하나 들어가고, 마지막으로 숫자 2자리가 들어갑니다.

여기서 `\d{1,}:`에서 `{1,}`은 하나 이상을 의미하는 것인데, 이를 쉽게 `+`이라고 바꿔 쓸 수 있습니다. 전체 코드에 이를 적용하면 다음과 같습니다.

```bash
rg '\d+:\s\$\d{3,}\.\d{2}' ex/5_7.txt
```

이 코드의 결과는 윗 코드와 같습니다.

## 과하게 일치하는 상황 방지하기

다음과 같은 `html` 문서가 있다고 가정합니다.

```html
This offer is not available to customers living in <B>AK</B> and <B>HI</B>.
```

참고로 이것은 `ex/5_8.html`에 들어 있습니다. 다음과 같이 확인하면 됩니다.

```bash
bat ex/5_8.html
```

여기서 강조 테크 , `<B>`, `</B>` 사이에 들어 있는 텍스트를 선택하고자 합니다. 지금까지 배운 것을 토대로 다음과 같이 패턴을 만들 수 있습니다, 다음은 `<`, `>` 사이에 `B` 또는 `b`가 있고, 이 뒤에 여러 개의 아무 문자나 오고 `/<`, `>` 사이에 `B` 또는 `b`가 있는 것을 찾는 패턴입니다.

```bash
rg '<[Bb]>.*</[Bb]>' ex/5_8.html
```

그런데 결과를 보면 `<B>AK</B> and <B>HI</B>` 전체를 선택하고 있습니다. 왜 그럴까요? 그 이유는 `*`이 '탐욕적 수량자(greedy quantifier)'이기 때문입니다. **탐욕적(greedy)**이라고 하는 이유는 이 수량자(quantifier)가 가능한 한 가장 큰 덩어리를 찾으려고 하기 때문입니다. 그래서 위의 문서에서 가장 긴 것을 찾고 있는 것입니다.

이렇게 탐욕적(greedy)인 일치 패턴을 원하지 않는다면, **게으른(lazy)** 수량자(quantifier)로 바꿔야 합니다. 여기서 **게으른(lazy)**이라는 부르는 이유는 문자가 최소로 일치하기 하기 때문입니다. **게으른(lazy)** 수량자는 **탐욕적(greedy)** 수량자 뒤에 `?`을 븉이면 됩니다. 다음 표를 참고하세요.

|greedy quantifier|lazy quantifier|
|:---:|:---:|
|`*`|`*?`|
|`+`|`+?`|
|`{`n`}`|`{`n`}?`|

앞에서 실행했던 패턴에서 탐욕적 수량자를 게으른 수량자로 바꿔 봅시다.

```bash
rg '<[Bb]>.*?</[Bb]>' ex/5_8.html
```
