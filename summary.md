# 정규 표현식 정리

## 메타 문자

### `.`

- 정리: 아무 문자나 한 문자가 있다.

```bash
echo "apple, appl" | rg 'appl.'
```

여기서 앞의 것만 찾고 뒤에 것을 못 찾습니다. 왜냐하면 `appl`에는 뒤에 문자가 없기 때문입니다.

```bash
echo "apple, appl" | rg 'app..'
```

이것도 마찬가지입니다. `appl`에는 `app`뒤에 한 문자만 있기 때문입니다. `app..`은 문자열 `app` 뒤에 아무 글자, 2개가 있는 것을 찾는 패턴입니다. 만약 `.`을 찾으려면 이스케이프 문자 `\`을 위에서처럼 사용해 햡니다. 다음 코드를 실행하면 알 수 있습니다.

```bash
echo "apple., appl" | rg 'app..\.'
```

### `+`

- 정리: 특정 패턴이 1개 이상 있다.

```bash
echo "app, ap, age" | rg 'ap+'
```

`ap+` 패턴은 `a` 다음에 `p`가 하나 이상 나온다는 패턴입니다. 여기서 앞의 문자열 2개는 패턴과 일치하지만, 마지막 것은 일치하는 패턴이 아니기 때문에 못 찾습니다.

### `*`

- 정리: 특정 패턴이 1개 이상 있어도 되지만 없어도 된다.

```bash
echo "app, ap, age" | rg 'ap*'
```

`ap+` 패턴은 `a` 다음에 `p`가 하나 이상 나오거나 없어도 된다는 패턴입니다. 다시 말해 `a`는 꼭 있어야 하지만, `p`은 없어도 됩니다. 그래서 여기서는 단어 3개를 모두 같은 패턴이라고 여기기 때문에 모두 선택하게 됩니다.

### `?`

- 정리: 특정 패턴이 1개가 있거나 또는 없어도 된다.

```bash
echo "https://www.naver.com/, http://www.naver.com/" | rg 'https?://[\w./]+'
```

`https?` 패턴은 `p` 다음에 `s`가 나오거나 없어도 된다는 패턴입니다. 다시 말해 `http`는 꼭 있어야 하지만, `s`은 없어도 됩니다.

### `{`N`}`

- 정리: `N` 번을 반복하는 패턴을 찾자.

```bash
echo "123, abc, defg, 456, 백두산" | rg '\d\d\d'
```

위와 같이 하면 숫자가 3개 연속적으로 있는 것을 찾을 수 있습니다. 그러나 `{3}`을 사용하면 위의 것을 단순하게 만들 수 있습니다.

```bash
echo "123, abc, defg, 456, 백두산" | rg '\d{3}'
```

### `{`N`,`M`}`

- 정리: 최소 `N`, 최대 `M`번을 반복하는 패턴을 찾자.

```bash
echo "1, 12, abc, defg, 456, 백두산, 7890" | rg '\d{2, 3}'
```

위와 같이 하면 숫자가 최소 2개 최대 3개가 연속적으로 있는 것을 찾을 수 있습니다. 만약 `{0, 2}`과 같이 한다면 없거나, 한 번, 또는 두 번 연속적으로 있는 것을 찾을 수 있습니다. 따라서 `{0, 1}`과 같이 한다면 없거나 또는 한 번 있거나 하는 것을 찾을 수 있습니다. 이 패턴은 `?`과 똑같은 기능을 하는 패턴입니다. 아래 코드를 참고하세요.

```bash
echo "https://www.naver.com/, http://www.naver.com/" | rg 'https{0, 1}://[\w./]+'
```

### `{`N`,}`

- 정리: 최소 `N`번을 반복하는 패턴을 찾자.

```bash
echo "1, 12, abc, defg, 456, 백두산, 7890" | rg '\d{2,}'
```

위와 같이 하면 최소 숫자 2자리 이상인 것을 찾게 됩니다. 만약 최소 1번을 반복하는 패턴을 찾으려면 앞에서 설명한 `+`을 사용하면 됩니다.

```bash
echo "1, 12, abc, defg, 456, 백두산, 7890" | rg '\d+'
```

## 탐욕적 수량자(greedy quantifier) vs. 게으른 수량자(lazy quantifier)

다음 코드를 살펴봅시다. 여기서 우리가 원하는 것은 `<B>철수</B>` 과 `<B>영희</B>`이 따로 분리되어 선택되는 것입니다.

```bash
echo "<B>철수</B> and <B>영희</B>." | rg '<[Bb]>.*</[Bb]>'
```

그러나 윗 코드를 실행하면 `<B>철수</B> and <B>영희</B>`을 선택하게 됩니다. 이렇게 된 이유는 `*`이 탐욕적 수량자(greedy quantifier)이기 때문입니다. 이 탐욕적 수량자은 가능한 한 큰 덩어리를 선택하도록 설계되어 있습니다. 만약 최소한 작은 덩어리를 선택하도록 하려고 한다면 탐욕적 수량자를 게으른 수량자(lazy quantifier)로 바꿔야 합니다. 바꾸는 방법은 탐욕적 수량자 뒤에 `?`을 븉이면 됩니다. 표로 정리하면 다음과 같습니다.

|greedy quantifier|lazy quantifier|
|:---:|:---:|
|`*`|`*?`|
|`+`|`+?`|
|`{`n`,}`|`{`n`,}?`|

앞의 코드를 게으른 수량자로 바꾸면 다음과 같습니다.

```bash
echo "<B>철수</B> and <B>영희</B>." | rg '<[Bb]>.*?</[Bb]>'
```

이제 윗 코드를 실행하면 `<B>철수</B>`과 `<B>영희</B>`을 분리해서 선택하게 됩니다.

## 이스케이프 문자: `\`

아래 메타 문자 자체를 찾기 위할 때 필요합니다. 아래 코드를 실행해 봅시다.

```bash
echo "apple.com, apple@com," | rg 'apple.com'
```

윗 패턴인 `apple.com`은 `apple`과 `com` 사이에 어떠한 문자 한 개가 있다는 패턴입니다. 이때 우리는 정확하게 `apple.com`만 찾고 싶다면, 즉 `.` 차체를 찾기 위해서는 `\`을 사용해서 `\.`과 같이 하면 됩니다. 다음 코트를 실행하면 알 수 있습니다.

```bash
echo "apple.com, apple@com," | rg 'apple\.com'
```
